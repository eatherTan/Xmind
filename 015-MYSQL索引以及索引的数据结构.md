# MYSQL索引以及索引的数据结构


索引 及索引的数据结构 ：http://blog.codinglabs.org/articles/theory-of-mysql-index.html

https://www.cnblogs.com/aspirant/p/9214485.html

## 索引的分类

#### 	从索引的数据结构角度分类

- B+树索引
- Hash索引
- Full-Text全文索引
- R-Tree索引

#### 	从物理存储角度分类

- 聚集索引 （Clustered Index）
- 非聚集索引（Non-Clustered Index ），也叫辅助索引（Secondary Index）
  注：聚集索引和非聚集索引都是B+树结构

下面来分别对每种结构进行分支，说明为什么当前MYSQL-InnoDb引擎选择B+树作为索引的数据结构

## 红黑树 - 平衡二叉树

​	可以做到自我平衡，但是一个父节点只能有两个子节点，导致树的高度太高，查询一次数据，需要与数据库进行多次IO操作，查找效率低。

## B树





## *B+树 - 索引的数据结构

### B+树的结构

- 叶子节点包含主键、行数据、指针，非叶子节点不存数据，只存储主键和相关指针

- 叶子节点之间由双向指针串联形成有序双向链表，叶子节点内部也是有序的

  > 主键就是聚集索引 （除了聚集索引，其他的都是非聚集索引）

### 聚集索引按照如下规则创建：

1.  有主键时InnoDB利用主键来生成
2.  没有主键，InnoDB会选择一个非空的唯一索引来创建
3.  无主键且非NULL唯一索引时，InnoDB会隐式创建一个自增的列来创建

### 为什么使用B+树结构？

根据磁盘和内存交互、随机磁盘IO、排序和范围查找、增删改的复杂度等等，综合考量之下B+树脱颖而出。

B+树作为多叉平衡树，对于范围查找和排序都可以很好地支持；

并且更加矮胖，访问数据时的平均磁盘IO次数取决于树的高度，因此B+树可以让磁盘的查找次数更少

### B树和B+树的区别：

**区别1：**

1. B树的每个节点都存储了key和data。

2. 而B+树只在叶子节点存储data数据。好处是：B+树的非叶子节点就能存储更多的key，所以B+树相对于B+更加矮胖。因为索引树很大不能一次IO读取进内存，所以树的深度越浅，查找数据时IO的次数就越少，效率就更高。

**区别2：**

1.  B+树的每个叶子节点的指针指向相邻的叶子节点，构成一个有序链表，可以按照key进行全部遍历。
2.  由于数据顺序排序并且相连，能很好地支持范围查询和排序，这是选择B+树而不选择B树作为索引的数据结构的最大原因。
3.  B树的叶子节点指针为null，相邻元素可能在内存中不相邻，所以缓存命中率没有B+树高。

### 磁盘预读机制和局部性原理

**局部性原理：**

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。

这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。

#### 当计算机访问一个数据时，不仅会加载当前数据所在的数据页，还会将当前数据页相邻的数据页一同加载到内存，磁盘预读的长度一般为页的整倍数，从而有效降低磁盘IO的次数。

