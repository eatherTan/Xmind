# Redis 基础
经常看到redis相关的内容，但是内容却是零散的。希望能够深入的了解redis的基础，redis的一些高级功能-集群、分布式所，都能有所了解。加油呀。以下是要去学习的内容：

- 为什么要选择Redis：介绍Redis的使用场景与使用Redis的原因；
- Redis常用命令总结：包括时间复杂度总结与具体数据类型在Redis内部使用的数据结构；
- Redis的高级功能：包括持久化（持久化的方式）、复制、哨兵、集群介绍；
- 理解Redis：理解内存、阻塞；这部分是非常重要的，前面介绍的都可以成为术，这里应该属于道的部分；
- redis分布式锁
- redis 缓存雪崩、击穿、穿透
- redis事务
- 开发技巧：主要是一些开发实战的总结，包括缓存设计与常见坑点。

## Redis概念
### Redis是什么？
根据官方的解释，Redis是一个基于RDS开源的项目，是一个把结构化数据放到内存的存储系统，你可以把它当做数据库、缓存和消息中间件使用。
*它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。* 它还内建了复制（replication），LUA脚本（LUA scripting），LRU驱动事件（LUR eviction），事务（transaction和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。

对上面说到的数据格式解释一下：
1. string：最基本的数据类型，二进制安全的字符串，最大512M。
1. list：按照添加顺序保持顺序的字符串列表。
1. set：无序的字符串集合，不存在重复的元素。
1. sorted set：已排序的字符串集合。
1. hash：key-value对的一种集合。bitmap：更细化的一种操作，以bit为单位。
2. hyperloglog：基于概率的数据结构。

> 上面标记斜体这句话不能理解。我一般看见的都是：Redis常见的数据结构：字符串String，集合Set，有序集合Sorted Set，数组List，散列Hash。

### 为什么要用redis？
1. 高性能，速度快
当某些业务需要频繁访问时，如果使用redis，将大大提高系统性能。数据存储在内存中，读写十分快，操作缓存就是直接操作内容，速度会比操作磁盘数据快上几个数量级。所以redis的特点就是速度快高性能。

2. 高并发
直接操作缓存能承受的请求是远远大于直接访问数据的。所以我们可以考虑把数据库中的部分数据转移到缓存中取，这样用户的一部分请求会直接到缓存而不用经过数据库。


### 使用Redis的优点？
1. 速度快。数据存储在内存中，在内存中读且很快。*类似于Hashmap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；*

2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门设计的；

3. redis采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多线程的切换而导致CPU的消耗，不用考虑各种锁的问题，不存在加锁释放锁的操作，没有因为可能出现死锁而导致的性能消耗；

4. 使用多路I/O复用模型，非阻塞IO；

5. 使用底层模型不同，他们之间的底层实现方式以及客户端之间的通信应用协议不一样，Redis直接自己构建VM机制，因为一般的系统调用函数的话，会浪费一定时间去移动和请求。

   > 上面斜体这句话没看懂，数据存储为什么说是类似HashMap的。

以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：

**多路 I/O 复用模型**
多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作

**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**

采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。

### 为什么Redis是单线程的？
我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。