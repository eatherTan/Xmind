# Java内存模型 JMM 

`sd`



每个线程有自己的工作内存，所有线程的工作内存中的变量都是从主内存中加载到工作内存的，工作内存更新了自己工作内存的变量后，再写入到主内存中。（变量是指实例变量和类变量，局部变量都在线程内，不会共享，也就不会有这个问题）

### JMM的三大特征：原子性、可见性、有序性

#### 原子性：

JMM只能保证基本数据类型是原子性的（double和long除外），原子性是指要不操作全部成功，要么全部失败，这个操作是不可分割的，不可中断的。

```
int x = 1;
int y = x;
x ++;
```

上面三行代码只有第一行是原子性操作，基本类型赋值操作，必定是原子性操作。

第二行代码先读取 x 变量的值，再进行赋值给 y 变量，进行了两个操作，不能保证原子性。

第三行代码先读取 x 变量的值，再进行加 1，最后再赋值给 x 变量，进行了三个操作，不能保证原子性。

在并发环境下，为了保证原子性，Java 提供了 synchronized 关键字。因此在 synchronized 修饰的代码块之间的操作都是原子性的。

#### 可见性：

可见性是指所有线程都能看到共享内存中最新的状态。如：一个线程更改了变量，其他线程也能立马看到最新的变量值。

Java提供了volatile关键字来保证可见性。只要在变量前使用该关键字就可以保证主内存中该变量是最新的值。

final 和  synchronized也能实现原子性，但是syncronized会导致线程阻塞。

#### 有序性：

因为硬件的读写速度不同，CPU的速度是内存的上百倍，所以CPU对指令进行了优化，如果在没有什么依赖的情况下，会对指令进行重排序，以优化程序执行速度。当这种情况，执行的指令顺序就不一定按照程序编写的顺序来，这就是重排序，会导致乱序。 JMM规定：如果重排序的顺序不影响当前逻辑，这是被允许的；

有序性是指程序执行的顺序按照代码的先后顺序执行。

volatile 和 syncronized 都可以保证有序性。

volatile 是通过加内存屏障来达到禁止指令重排序，来保证有序性。

疑问： <u>syncronized 的原理是：一个变量在同一时刻只能被一个线程lock，必须释放锁以后其他线程才能lock，使得syncronized修饰的代码块在多线程之间是串行的</u>



------



