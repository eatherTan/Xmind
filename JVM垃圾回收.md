# JVM 垃圾回收

## 1.JVM是什么

JVM是Java Virtual Machine（Java虚拟机）的缩写。Java语言有一个特性是“一次编译，到处运行”，这是因为有了JVM之后，Java语言在不同平台上运行时**不需要重新编译**。Java语言的Java文件(.java)通过Java语言的编译程序（javac）被编译为.class字节码文件。.class字节码文件只要有对应平台的Java虚拟机，如Windows系统的Java虚拟机或Linux系统的Java虚拟机，那么字节码文件(.class) 就可以再对应的平台上运行。

因此可以看到，Java实现跨平台，不是指Java文件能在不同平台上运行，而是被编译后的字节码文件(.class文件)可以通过JVM虚拟机在不同平台上运行,从而实现“一次编译，到处运行”。

## 2.JVM 运行流程

这个是JVM的组成图，由四个部分组成： 

- **类加载器**
- **执行引擎**
- **本地接口**
- **运行时数据区**

![用来下载图片 - jvm](C:\Users\tanxiaolian\Downloads\用来下载图片 - jvm.png)

## 3.JVM运行时区域

=

## 2.判断对象无效

对于Java对象来讲，如果说这个对象没有被其他对象所引用该对象就是无用的，此对象就被称为垃圾，其占用的内存也就要被销毁。

#### Java中标记垃圾的算法主要有两种， 引用计数法和可达性分析算法。

### 1.**引用计数法**

引用计数法就是给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的，可以当做垃圾收集。这种方法实现起来很简单而且优缺点都很明显。

优点 执行效率高，程序执行受影响较小

缺点 无法检测出循环引用的情况，导致内存泄露

### 2.**可达性分析算法**

这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

被称为GC Roots 的对象有哪些？

> 1.在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈用使用到的参数、局部变量、临时变量等
>
> 2.在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
>
> 3.在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用
>
> 4.在本地方法栈中INI（即通常所说的Native方法）引用的对象
>
> 5.在虚拟机内部的引用，如基本数据类型对象的Class对象，一些常驻的异常对象（比如NullPointerException，OutOfMemoryError）等，还有系统类加载器



## 3.垃圾回收算法

在Java中存在着四种垃圾回收算法，标记清除算法、复制算法、标记整理算法以及分代回收算法

这些算法都基于三个理论、思想

（1）弱分代假说：绝大多数对象都是“朝生夕灭”的。

（2）强分代假说：

（3）跨分代引用假说： - - 待确认

(1), (2) 这两个分代假说表明了垃圾收集器一致设计的原则：应该将Java堆划分为多个不同的区域，然后根据对象的年龄（年龄指的是熬过垃圾收集的次数）分配到不同的区域，比如：如果一个区域中的对象绝大多数都是朝生夕灭，应该将这些对象集中放置在一块区域，每次垃圾收集时只需要关注如何去保存少量存活的对象，而不是去标记大量将要回收的对象，以较低的代价回收这块区域；如果 剩下的都是难以消亡的对象，便可以把这些对象集中放置另一块区域，在垃圾回收时只关注少量将要回收的对象。这就同时兼顾了内存的空间和时间的效率。

### **1. 标记 - 清除算法** 



标记清除算法是最基础的收集算法，其他收集算法都是基于这种思想。标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，标记完成之后统一清除对象。

它的主要缺点：①.标记和清除过程效率不高 。

②.标记清除之后会产生大量不连续的内存碎片。

[![img](http://static.oschina.net/uploads/img/201303/18092408_8VSx.jpg)](http://static.oschina.net/uploads/img/201303/18092408_8VSx.jpg)、

![用来下载图片](C:\Users\tanxiaolian\Downloads\用来下载图片.png)

### **2. 复制算法**

它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。

主要缺点：内存缩小为原来的一半。

[![img](http://static.oschina.net/uploads/img/201303/18092409_CEnW.jpg)](http://static.oschina.net/uploads/img/201303/18092409_CEnW.jpg)



![复制算法](C:\Users\tanxiaolian\Downloads\复制算法.png)

### **3. 标记 - 整理算法**

标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。

主要缺点：在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。

[![img](http://static.oschina.net/uploads/img/201303/18092409_6Gwi.jpg)](http://static.oschina.net/uploads/img/201303/18092409_6Gwi.jpg)

[![img](http://static.oschina.net/uploads/img/201303/18092410_aV8b.jpg)](http://static.oschina.net/uploads/img/201303/18092410_aV8b.jpg)

4、分代收集算法 

根据对象的存活周期的不同将内存划分为几块。一般把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-整理”算法进行回收。





减少





































