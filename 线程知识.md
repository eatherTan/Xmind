# 线程知识

> 尽量涉及这些知识：单线程扩展到并发编程，从并发编程深入到线程同步、线程安全、进程间通信

## 线程是什么

1. 线程是CPU调度和分派的最小单位，它可与同属于同一个进程的其他线程，共享进程所拥有的全部资源。
2. 一个进程下可以有多个线程，但至少有一个线程。

线程和进程的区别是什么？

1. 进程：进程是程序的一次执行过程，是一个动态概念。

2. 线程： 线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

3. **根本区别：从资源使用的角度出发（资源就是计算机里的中央处理器，内存，文件，网络）。进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。**

   - **在开销方面：**每个进程都有独立的代码和上下文（数据空间），进程的创建、销毁、切换产生大量的时间和空间的开销；而线程的切换开销小，因为线程有自己的程序计数器可以快速回复到上次执行的位置；并且线程可以看做是轻量级的进程，同一类线程共享资源。

   - **在系统资源方面：** 系统在运行时会为每个进程分配不同的内存空间，比如堆、栈；线程基本不拥有系统资源，只有一些运行时必不可少的资源，比如程序计数器、寄存器和栈，



## 线程的创建

> 创建线程的方式
>
> 1. 继承Thread类
>
> 2. 实现Runnable接口
>
> 3. 实现Callable

1.  ##### 继成`java.lang.Thread`, 重写run()方法

   ```java
   public class ThreadByExtendsThread extends Thread{
       @Override
       public void run() {
           super.run();
           for (int i = 0; i < 20; i++) {
               System.out.println("我在学习创建多线程====" + i);
           }
           System.out.println("==========");
       }
       public static void main(String[] args) {
           ThreadByExtendsThread thread1 = new ThreadByExtendsThread();
           ThreadByExtendsThread thread2 = new ThreadByExtendsThread();
           ThreadByExtendsThread thread3 = new ThreadByExtendsThread();
           thread1.start();
           thread2.start();
           System.out.println(Thread.currentThread().getName());
           //数字紊乱，发现不是按照i的顺序来执行的，有线程安全问题
       }
   }
   ```

2. ##### 实现Runnable接口，重写run()方法

   ```java
   public class ThreadByImplementRunnable implements Runnable{
   
       @Override
       public void run() {
           for (int i = 0; i < 20; i++) {
               System.out.println("我在听课====" + i);
           }
           System.out.println("==========");
       }
       public static void main(String[] args) {
           ThreadByImplementRunnable thread1 = new ThreadByImplementRunnable();
           new Thread(thread1).start();
           //或者也可以写成：
           //Thread t1 = new Thread(thread1);
           //t1.start();
       }
   }
   ```

> 继承Thread类和实现Callable接口这两种方式很相像，两种方式都需要重写run()方法，然后再调用Thread类的start()方法来启动线程。
>
> 本质没有明显的区别，但是写法有一些区别。第一种方式是继承Thread类，因为Java是单继承的，如果一个类继承了Thread类，那么这个类就不能再继承其他类了，在继承上有一些限制；第二种方式是为了解决第一种方式的单继承不灵活的问题；因此平常多使用的是第二种方式。

3. ##### 实现Callable接口

```
/**
 * 1.实现Callable接口，需要返回值类型
 * 2.重写call方法，需要抛出异常
 * 3.创建目标对象
 * 4.创建线程执行服务： ExecutorService service = Executors.newFixedThreadPool(1);
 * 5.提交执行：Futrue<Boolean> result = service.submit();
 * 6.获取结果：Boolean r1 = result.get();
 * 7.关闭服务：service.shutdown();
 */
 
 public class ThreadByImplementsCallable implements Callable<Boolean> {

    private String url;
    private String name;

    public ThreadByImplementsCallable(String url,String name){
        this.url = url;
        this.name = name;
    }

    @Override
    public Boolean call() throws Exception {
        WebDownLoader webDownLoader = new WebDownLoader();
        webDownLoader.downLoader(url, name);
        System.out.println("下载了文件名为：" + name);
        return true;
    }

    public static void main(String[] args) {
        ThreadByImplementsCallable t1 = new ThreadByImplementsCallable("https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2763858159,801771131&fm=26&gp=0.jpg","图片1");
        ThreadByImplementsCallable t2 = new ThreadByImplementsCallable("https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2763858159,801771131&fm=26&gp=0.jpg","图片2");
        ThreadByImplementsCallable t3 = new ThreadByImplementsCallable("https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2763858159,801771131&fm=26&gp=0.jpg","图片3");

        //1.创建执行服务
        ExecutorService service = Executors.newFixedThreadPool(3);
        //2.提交执行
        Future<Boolean> r1 = service.submit(t1);
        Future<Boolean> r2 = service.submit(t2);
        Future<Boolean> r3 = service.submit(t3);
        //3.获取结果
        try {
            boolean rs1 = r1.get();
            boolean rs2 = r2.get();
            boolean rs3 = r3.get();
            //4.关闭服务
            service.shutdown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }
}
```



## 线程的状态

1. 创建状态（New）：new Thread(); 创建完成以后需要为线程分配内存
2. 就绪状态（Runnable）：调用了start()方法，等待CPU的调度
3. 运行状态（Running）：执行run()方法
4. 阻塞状态（Blocking）：暂时停止执行线程，将线程挂起（sleep(), wait(), join(), 没有获取到锁都会使线程阻塞），可能将资源给其他线程使用
5. 死亡状态（Terminated）： 线程销毁(正常执行完毕、发生异常或者被打断interrupt()都会导致线程终止)



## 线程不安全的原因

线程不安全的原因是因为<u>主内存和工作内存数据不一致性和重排序</u>导致的；那这就需要我们去解决。

先了解一下Java的内存模型：

#### 1.1共享变量：

- 方法区和堆是所有线程共享的，所有线程均可以访问。如：静态变量是放在方法区的，数组、对象实例是放在堆内存中的。
- 虚拟机栈和本地方法栈、程序计数器是线程私有的。如：局部变量，方法定义参数和异常处理器参数不会在线程中共享。
- 共享区域的数据会出现线程安全问题，而非共享数据不会出现线程安全问题。

#### 1.2JMM内存模型

- 让我们来了解一下CPU 和主内存的读写速度。一级、二级、三级、主内存的访问时间，CPU的速度基本和第一级Cache一致。可见CPU的速度是主内存的100倍左右

  > 1st level cache / 1st level TLB   1ns
  >
  > 2nd level cache / 2nd level TLB   4ns
  >
  > 3rd level cache                   TLB   12ns
  >
  > Memory(DRAM)                         100ns

cpu处理数据可以简单认为是读取，运算，回写，在我们看来cpu处理速度高于内存。但是数据并不是直接就能使用通常要经过大量计算，如果在计算时大量访问内存会使得程序的性能会大幅下降（原因是访问内存的速度慢），内存访问次数越多，性能越差，所以才引入缓存从而减少cpu访问内存的次数。我们常常会在CPU(处理器)中加入**高速缓存（Cache Memory）**，也就是将数据缓存到处理器中，当处理器处理完数据后，再将处理的数据结果存储在内存中。

**Java线程之间的通信有Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对其他线程可见。**

*共享变量是放在主内存中，每个线程都有属于自己的工作内存，并且会把位于主内存的共享变量拷贝到自己的工作内存中，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主内存中。*



如图为JMM抽象示意图，线程A和线程B之间要完成通信的话，要经历如下两步：

1. 线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；
2. 线程B从主存中读取最新的共享变量

> 从这里就可以看出这里有时差性的问题，因此这里容易出现线程安全问题。
>
> <u>如果线程A更新了工作内存中的共享变量的副本，但是却没有及时回写到主内存，而此时线程B来读取数据，因此B读到的是过期的数据，这就出现了“脏读”现象。可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过volatile关键字使得每次volatile变量都能够强制刷新到主内存，从而对每个线程都是可见的。</u>

#### 1.3重排序

这个还没怎么了解



## 线程间的通信

线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。线程通信常用的方式有

- `wait/notify` 等待
- `volatile` 内存共享
- `CountDownLatch` 并发工具

- `CyclicBarrier` 并发工具

#### 1.1`volatile`关键字

volatile关键字保证了数据的可见性。如何保证的呢？

volatile关键字修饰变量，即告知线程对该变量的访问必须从主内存中获取；对volatile变量的改变必须同步刷新到主内存中。

#### 1.2