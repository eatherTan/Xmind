# 线程知识

> 尽量涉及这些知识：单线程扩展到并发编程，从并发编程深入到线程同步、线程安全、进程间通信

## 线程是什么

1. 线程是CPU调度和分派的最小单位，它可与同属于同一个进程的其他线程，共享进程所拥有的全部资源。
2. 一个进程下可以有多个线程，但至少有一个线程。

线程和进程的区别是什么？

1. 进程：进程是程序的一次执行过程，是一个动态概念。

2. 线程： 线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

3. **根本区别：从资源使用的角度出发（资源就是计算机里的中央处理器，内存，文件，网络）。进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。**

   - **在开销方面：**每个进程都有独立的代码和上下文（数据空间），进程的创建、销毁、切换产生大量的时间和空间的开销；而线程的切换开销小，因为线程有自己的程序计数器可以快速回复到上次执行的位置；并且线程可以看做是轻量级的进程，同一类线程共享资源。

   - **在系统资源方面：** 系统在运行时会为每个进程分配不同的内存空间，比如堆、栈；线程基本不拥有系统资源，只有一些运行时必不可少的资源，比如程序计数器、寄存器和栈，



## 线程的创建

> 创建线程的方式
>
> 1. 继承Thread类
>
> 2. 实现Runnable接口
>
> 3. 实现Callable

1.  ##### 继成`java.lang.Thread`, 重写run()方法

   ```java
   public class ThreadByExtendsThread extends Thread{
       @Override
       public void run() {
           super.run();
           for (int i = 0; i < 20; i++) {
               System.out.println("我在学习创建多线程====" + i);
           }
           System.out.println("==========");
       }
       public static void main(String[] args) {
           ThreadByExtendsThread thread1 = new ThreadByExtendsThread();
           ThreadByExtendsThread thread2 = new ThreadByExtendsThread();
           ThreadByExtendsThread thread3 = new ThreadByExtendsThread();
           thread1.start();
           thread2.start();
           System.out.println(Thread.currentThread().getName());
           //数字紊乱，发现不是按照i的顺序来执行的，有线程安全问题
       }
   }
   ```

2. ##### 实现Runnable接口，重写run()方法

   ```java
   public class ThreadByImplementRunnable implements Runnable{
   
       @Override
       public void run() {
           for (int i = 0; i < 20; i++) {
               System.out.println("我在听课====" + i);
           }
           System.out.println("==========");
       }
       public static void main(String[] args) {
           ThreadByImplementRunnable thread1 = new ThreadByImplementRunnable();
           new Thread(thread1).start();
           //或者也可以写成：
           //Thread t1 = new Thread(thread1);
           //t1.start();
       }
   }
   ```

> 继承Thread类和实现Callable接口这两种方式很相像，两种方式都需要重写run()方法，然后再调用Thread类的start()方法来启动线程。
>
> 本质没有明显的区别，但是写法有一些区别。第一种方式是继承Thread类，因为Java是单继承的，如果一个类继承了Thread类，那么这个类就不能再继承其他类了，在继承上有一些限制；第二种方式是为了解决第一种方式的单继承不灵活的问题；因此平常多使用的是第二种方式。

3. ##### 实现Callable接口

```
/**
 * 1.实现Callable接口，需要返回值类型
 * 2.重写call方法，需要抛出异常
 * 3.创建目标对象
 * 4.创建线程执行服务： ExecutorService service = Executors.newFixedThreadPool(1);
 * 5.提交执行：Futrue<Boolean> result = service.submit();
 * 6.获取结果：Boolean r1 = result.get();
 * 7.关闭服务：service.shutdown();
 */
 
 public class ThreadByImplementsCallable implements Callable<Boolean> {

    private String url;
    private String name;

    public ThreadByImplementsCallable(String url,String name){
        this.url = url;
        this.name = name;
    }

    @Override
    public Boolean call() throws Exception {
        WebDownLoader webDownLoader = new WebDownLoader();
        webDownLoader.downLoader(url, name);
        System.out.println("下载了文件名为：" + name);
        return true;
    }

    public static void main(String[] args) {
        ThreadByImplementsCallable t1 = new ThreadByImplementsCallable("https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2763858159,801771131&fm=26&gp=0.jpg","图片1");
        ThreadByImplementsCallable t2 = new ThreadByImplementsCallable("https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2763858159,801771131&fm=26&gp=0.jpg","图片2");
        ThreadByImplementsCallable t3 = new ThreadByImplementsCallable("https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2763858159,801771131&fm=26&gp=0.jpg","图片3");

        //1.创建执行服务
        ExecutorService service = Executors.newFixedThreadPool(3);
        //2.提交执行
        Future<Boolean> r1 = service.submit(t1);
        Future<Boolean> r2 = service.submit(t2);
        Future<Boolean> r3 = service.submit(t3);
        //3.获取结果
        try {
            boolean rs1 = r1.get();
            boolean rs2 = r2.get();
            boolean rs3 = r3.get();
            //4.关闭服务
            service.shutdown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }
}
```



## 线程的状态

1. 创建状态（New）：new Thread(); 创建完成以后需要为线程分配内存
2. 就绪状态（Runnable）：调用了start()方法，等待CPU的调度
3. 运行状态（Running）：执行run()方法
4. 阻塞状态（Blocking）：暂时停止执行线程，将线程挂起（sleep(), wait(), join(), 没有获取到锁都会使线程阻塞），可能将资源给其他线程使用
5. 死亡状态（Terminated）： 线程销毁(正常执行完毕、发生异常或者被打断interrupt()都会导致线程终止)



## 线程不安全的原因

线程不安全的原因是因为<u>主内存和工作内存数据不一致性和重排序</u>导致的；那这就需要我们去解决。

先了解一下Java的内存模型：

#### 1.1共享变量：

- 方法区和堆是所有线程共享的，所有线程均可以访问。如：静态变量是放在方法区的，数组、对象实例是放在堆内存中的。
- 虚拟机栈和本地方法栈、程序计数器是线程私有的。如：局部变量，方法定义参数和异常处理器参数不会在线程中共享。
- 共享区域的数据会出现线程安全问题，而非共享数据不会出现线程安全问题。

#### 1.2JMM内存模型

- 让我们来了解一下CPU 和主内存的读写速度。一级、二级、三级、主内存的访问时间，CPU的速度基本和第一级Cache一致。可见CPU的速度是主内存的100倍左右

  > 1st level cache / 1st level TLB   1ns
  >
  > 2nd level cache / 2nd level TLB   4ns
  >
  > 3rd level cache                   TLB   12ns
  >
  > Memory(DRAM)                         100ns

cpu处理数据可以简单认为是读取，运算，回写，在我们看来cpu处理速度高于内存。但是数据并不是直接就能使用通常要经过大量计算，如果在计算时大量访问内存会使得程序的性能会大幅下降（原因是访问内存的速度慢），内存访问次数越多，性能越差，所以才引入缓存从而减少cpu访问内存的次数。我们常常会在CPU(处理器)中加入**高速缓存（Cache Memory）**，也就是将数据缓存到处理器中，当处理器处理完数据后，再将处理的数据结果存储在内存中。

**Java线程之间的通信有Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对其他线程可见。**

*共享变量是放在主内存中，每个线程都有属于自己的工作内存，并且会把位于主内存的共享变量拷贝到自己的工作内存中，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主内存中。*



如图为JMM抽象示意图，线程A和线程B之间要完成通信的话，要经历如下两步：

1. 线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；
2. 线程B从主存中读取最新的共享变量

> 从这里就可以看出这里有时差性的问题，因此这里容易出现线程安全问题。
>
> <u>如果线程A更新了工作内存中的共享变量的副本，但是却没有及时回写到主内存，而此时线程B来读取数据，因此B读到的是过期的数据，这就出现了“脏读”现象。可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过volatile关键字使得每次volatile变量都能够强制刷新到主内存，从而对每个线程都是可见的。</u>

#### 1.3重排序

这个还没怎么了解

#### 1.4总结

- 在物理计算机中CPU为了提高处理速度，添加了高速缓存与CPU乱序执行

- Java定义了自身的**内存模型**是为了屏蔽掉不同硬件和操作系统的内存模型差异

- Java为了处理内存的不可见性与重排序的问题，定义了**Happens-Before 原则**

- Happens-Before 原则的理解：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。



## 线程间的通信

线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。线程通信常用的方式有

- `wait/notify` 等待
- `volatile` 内存共享
- `CountDownLatch` 并发工具

- `CyclicBarrier` 并发工具

#### 1.1`volatile`关键字

volatile关键字保证了数据的可见性。如何保证的呢？

volatile关键字修饰变量，即告知线程对该变量的访问必须从主内存中获取；对volatile变量的改变必须同步刷新到主内存中。

#### 1.2 等待通知机制 

`syncronized` 配套 `wait()/notify()`, `wait()/notifyAll()`





# Syncronized实现原理

## 1.使用场景

可以用在变量、代码块、方法中，根据Syncronized使用的位置有不同的

### 1.1方法

**实例方法**

syncronized 用在实例方法上

被锁住的对象是：类的实例对象

```
//实例方法，锁住的是该类的实例对象
public syncronized void method(){
	...
}
```

**静态方法**

syncronized 用在静态方法上

被锁住的对象是类对象

```
//静态方法，锁住的是类对象
public static syncronized void method(){
	...
}
//或者
public void lockClass(){
	syncronized(ClassLock.class){
		...
	}
}

```

> **类锁和对象锁的区别：**
>
> 对象锁的疑问：如果有多个实例对象，那就会有多把锁吗 每个对象一把锁
>
> - 类锁：
>   - 类锁是一个class其中的静态方法或者静态变量在内存中只会加载初始化一份，所以，一旦一个静态方法被申明为syncronized，此类的所有的实例化对象在调用该方法时，共用同一把锁，称之为类锁。
>   - 类锁是加在类上的，而类信息是存在JVM方法区的，并且整个JVM只有一份，方法区是所有线程共享的，所以类锁是线程共享的。
>   - 线程获得对象锁的同时，也可以获得类锁，类锁和对象锁是两个不一样的锁，互不干扰
>
> - 对象锁
>   - 对象锁是当一个对象中有同步方法或者同步块，线程调用此对象进入该同步区域时，必须获得对象锁。如果此对象的对象锁被其他线程占用，则该线程进入阻塞队列，等待此锁释放（同步块正常返回或者抛异常终止，由JVM自动释放对象锁）
>   - 注意，方法锁也是一种对象锁。
>
> - ##### 重要：对象锁是用来控制实例方法之间的同步，而类锁是用来控制静态方法（或者静态变量互斥体）之间的同步的。

### 1.2代码块

**实例对象、任意实例对象**

被锁住的对象是实例对象

```
//实例对象
syncronized(this){...}

//任意实例对象
String lock = "";
syncronized(lock){...}
```

**Class对象**

被锁住的对象是 Class对象

```
//被锁住的对象是 Class对象
syncronized(SyncronizedDemo.class){
	...
}
```

### 总结一下

| 分类   | 具体分类           | 被锁住的对象   | 是否线程共享锁 | 伪代码                                                       |                                                              |
| ------ | :----------------- | -------------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 变量   | 普通变量           |                |                |                                                              |                                                              |
|        | 静态变量           | 类对象         | 是             | private static Object lock = new Object();<br/>synchronized (lock){...} |                                                              |
| 方法   | 实例方法           | 类的实例对象   | 否             | //实例方法，锁住的是该类的实例对象<br/>public syncronized void method(){...} | 方法一旦执行，就独占该锁，一直到该方法返回时才将锁释放，此后阻塞的线程才能获得该锁，从而重新进入可执行状态 |
|        | 静态方法           | 类对象         | 是，线程共享锁 | //静态方法，锁住的是类对象<br/>public static syncronized void method(){...} | 类锁是所有线程共享的锁，所以同一适合，只能有一个线程使用加锁的的方法或方法体，不管是不是同一个实例。 |
| 代码块 | 实例对象this       | 类的实例对象   | 否             | syncronized(this){...}                                       |                                                              |
|        | Class对象          | 类对象         | 是             | syncronized(SyncronizedDemo.class){...}                      |                                                              |
|        | 任意实例对象Object | Object实例对象 | 否             | String lock = "";<br/>syncronized(lock){...}                 |                                                              |



2. 对象锁（monitor）

























