# 没有排序，数据库查询排序却不一致

没有指定排序的的查询SQL，索引会影响查询出来

> 经过：
>
> 做一个接口的自动化测试，在测试时发现，接口返回数据顺序与我去查询数据库的顺序不一致，导致校验通不过。这个接口的需求对返回的年级科目数据是没有顺序要求的，所以我在写j接口测试的SQL时也就没有指定顺序，但是跑自动化测试时总是断言不通过。于是我去查看项目代码：确认一下开发是否指定了排序。如果是的话，我只要在我的sql中新增一下排序，那么校验就会通过。
>
> 可是仔细查看接口逻辑后，并没有发现指定排序的逻辑。这时求助开发，让开发再确认一下是否有某个地方指定了排序，开发查看代码后确认代码中没有指定排序，至于为什么排序会不一致我们来排查一下。



表结构

```
CREATE TABLE `t_publish_grade_group_course` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'id',
  `ref_id` bigint(20) NOT NULL COMMENT 'refId',
  `ref_type` tinyint(4) NOT NULL COMMENT 'refType',
  `grade_group` int(11) NOT NULL COMMENT '年部',
  `course_id` int(11) NOT NULL COMMENT '科目',
  `is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否删除',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `last_update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_ref_id_ref_type` (`ref_id`,`ref_type`),
  KEY `idx_ref_type_course_id_grade_group` (`ref_type`,`course_id`,`grade_group`)
) ENGINE=InnoDB AUTO_INCREMENT=178 DEFAULT CHARSET=utf8 COMMENT='年部科目表';

```

## 思考

思考一个问题：结合上面的表结构，思考：下面两个查询语句，他们的排序是按照什么来排序的，他们的排序规则是一样的吗?

```
1. SELECT * from t_publish_grade_group_course where is_deleted =0  and ref_type = 2 and ref_id in (8);

2. SELECT * from t_publish_grade_group_course where is_deleted =0  and ref_type = 2 and ref_id in (1,8,12,16,10);
```

## 分析SQL语句

1.先来看第一个查询，执行一下这个SQL

```
mysql> SELECT * from t_publish_grade_group_course where is_deleted =0  and ref_type = 2 and ref_id in (8);
+-----+--------+----------+-------------+-----------+------------+---------------------+---------------------+
| id  | ref_id | ref_type | grade_group | course_id | is_deleted | create_time         | last_update_time    |
+-----+--------+----------+-------------+-----------+------------+---------------------+---------------------+
| 153 |      8 |        2 |           3 |         5 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
| 154 |      8 |        2 |           3 |         4 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
| 155 |      8 |        2 |           3 |         3 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
| 156 |      8 |        2 |           3 |         2 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
| 157 |      8 |        2 |           3 |         1 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
+-----+--------+----------+-------------+-----------+------------+---------------------+---------------------+
5 rows in set
```

可以看到查询结果，仔细观察数据，查出来的数据排序好像符合我们的预期：当没有指定排序时按照id升序来排序。（其实不是这样的，具体可以看SQL解析）

解析一下SQL语句- explain

```
mysql> explain SELECT * from t_publish_grade_group_course where is_deleted =0  and ref_type = 2 and ref_id in (8);
+----+-------------+------------------------------+------------+------+--------------------------------------------------------+---------------------+---------+-------------+------+----------+-------------+
| id | select_type | table                        | partitions | type | possible_keys                                          | key                 | key_len | ref         | rows | filtered | Extra       |
+----+-------------+------------------------------+------------+------+--------------------------------------------------------+---------------------+---------+-------------+------+----------+-------------+
|  1 | SIMPLE      | t_publish_grade_group_course | NULL       | ref  | idx_ref_id_ref_type,idx_ref_type_course_id_grade_group | idx_ref_id_ref_type | 9       | const,const |    5 |       10 | Using where |
+----+-------------+------------------------------+------------+------+--------------------------------------------------------+---------------------+---------+-------------+------+----------+-------------+
1 row in set
```

**可以看到使用的key是 `idx_ref_id_ref_type`**，索引影响了查询结果的排序。

此时再看一下第2个SQL语句

```
mysql> SELECT * from t_publish_grade_group_course where is_deleted =0  and ref_type = 2 and ref_id in (1,8,12,16,10);
+-----+--------+----------+-------------+-----------+------------+---------------------+---------------------+
| id  | ref_id | ref_type | grade_group | course_id | is_deleted | create_time         | last_update_time    |
+-----+--------+----------+-------------+-----------+------------+---------------------+---------------------+
| 165 |      1 |        2 |           1 |         1 |          0 | 2021-04-08 11:13:19 | 2021-04-08 11:13:19 |
| 174 |     16 |        2 |           1 |         1 |          0 | 2021-04-08 16:52:02 | 2021-04-08 16:52:02 |
| 175 |     16 |        2 |           2 |         1 |          0 | 2021-04-08 16:52:02 | 2021-04-08 16:52:02 |
| 157 |      8 |        2 |           3 |         1 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
| 166 |      1 |        2 |           2 |         2 |          0 | 2021-04-08 11:13:19 | 2021-04-08 11:13:19 |
| 156 |      8 |        2 |           3 |         2 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
| 164 |     10 |        2 |           3 |         2 |          0 | 2021-04-08 11:10:30 | 2021-04-08 11:10:30 |
| 176 |     16 |        2 |           3 |         2 |          0 | 2021-04-08 16:52:02 | 2021-04-08 16:52:02 |
| 155 |      8 |        2 |           3 |         3 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
| 154 |      8 |        2 |           3 |         4 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
| 153 |      8 |        2 |           3 |         5 |          0 | 2021-04-01 14:56:38 | 2021-04-01 14:56:38 |
| 163 |     10 |        2 |           2 |         6 |          0 | 2021-04-08 11:10:30 | 2021-04-08 11:10:30 |
| 177 |     12 |        2 |           3 |        12 |          0 | 2021-04-10 11:16:50 | 2021-04-10 11:16:50 |
+-----+--------+----------+-------------+-----------+------------+---------------------+---------------------+
13 rows in set
```

从搜索结果中可以看出，这次查询结果的排序并不是按照id升序排的，似乎是按照course_id升序排序的。仔细观察：第一条SQL和第二条SQL几乎是同一条语句，只是传入的数据不同，为什么会导致这样的结果呢？

解析一下第二条SQL语句- explain；

```
mysql> explain SELECT * from t_publish_grade_group_course where is_deleted =0  and ref_type = 2 and ref_id in (1,8,12,16,10);
+----+-------------+------------------------------+------------+------+--------------------------------------------------------+------------------------------------+---------+-------+------+----------+-------------+
| id | select_type | table                        | partitions | type | possible_keys                                          | key                                | key_len | ref   | rows | filtered | Extra       |
+----+-------------+------------------------------+------------+------+--------------------------------------------------------+------------------------------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | t_publish_grade_group_course | NULL       | ref  | idx_ref_id_ref_type,idx_ref_type_course_id_grade_group | idx_ref_type_course_id_grade_group | 1       | const |   45 |        5 | Using where |
+----+-------------+------------------------------+------------+------+--------------------------------------------------------+------------------------------------+---------+-------+------+----------+-------------+
```

可以看到这次使用的key是`idx_ref_type_course_id_grade_group`，由此可以判断是索引影响了查询结果的排序。下面来学习一下索引，和**索引对查询的优化，和数据库是如何选择最佳索引**。



## 索引





