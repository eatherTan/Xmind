# `MYSQL`索引以及索引的数据结构


索引 及索引的数据结构 ：http://blog.codinglabs.org/articles/theory-of-mysql-index.html

https://www.cnblogs.com/aspirant/p/9214485.html

## 索引的分类

#### 	从索引的数据结构角度分类

- B+树索引
- Hash索引
- Full-Text全文索引
- R-Tree索引

#### 	从物理存储角度分类

- 聚集索引 （`Clustered Index`）
- 非聚集索引（`Non-Clustered Index` ），也叫辅助索引（`Secondary Index`）
  注：聚集索引和非聚集索引都是B+树结构

下面来分别对每种结构进行分支，说明为什么当前`MYSQL`-`InnoDb`引擎选择B+树作为索引的数据结构

## 红黑树 - 平衡二叉树

​	可以做到自我平衡，但是一个父节点只能有两个子节点，导致树的高度太高，查询一次数据，需要与数据库进行多次IO操作，查找效率低。

## B树





## *B+树 - 索引的数据结构

### B+树的结构

- 叶子节点包含主键、行数据、指针，非叶子节点不存数据，只存储主键和相关指针

- 叶子节点之间由双向指针串联形成有序双向链表，叶子节点内部也是有序的

- 叶子节点会冗余非叶子节点，为了查找快速，范围查询方便等

  > 主键就是聚集索引 （除了聚集索引，其他的都是非聚集索引）

### 聚集索引按照如下规则创建：

1.  有主键时`InnoDB`利用主键来生成
2.  没有主键，`InnoDB`会选择一个非空的唯一索引来创建
3.  无主键且非NULL唯一索引时，`InnoDB`会隐式创建一个自增的列来创建

### 为什么使用B+树结构？

根据磁盘和内存交互、随机磁盘IO、排序和范围查找、增删改的复杂度等等，综合考量之下B+树脱颖而出。

B+树作为多叉平衡树，对于范围查找和排序都可以很好地支持；

并且更加矮胖，访问数据时的平均磁盘IO次数取决于树的高度，因此B+树可以让磁盘的查找次数更少

### B树和B+树的区别：

**区别1：**

1. B树的每个节点都存储了key和data。

2. 而B+树只在叶子节点存储data数据。好处是：B+树的非叶子节点就能存储更多的key，所以B+树相对于B+更加矮胖。因为索引树很大不能一次IO读取进内存，所以树的深度越浅，查找数据时IO的次数就越少，效率就更高。

**区别2：**

1.  B+树的每个叶子节点的指针指向相邻的叶子节点，构成一个有序链表，可以按照key进行全部遍历。
2.  由于数据顺序排序并且相连，能很好地支持范围查询和排序，这是选择B+树而不选择B树作为索引的数据结构的最大原因。
3.  B树的叶子节点指针为null，相邻元素可能在内存中不相邻，所以缓存命中率没有B+树高。

### 磁盘预读机制和局部性原理

**局部性原理：**

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。

这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。

当计算机访问一个数据时，不仅会加载当前数据所在的数据页，还会将当前数据页相邻的数据页一同加载到内存，磁盘预读的长度一般为页的整倍数，从而有效降低磁盘IO的次数。



## Hash 索引的限制和弊端

Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B+Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B+Tree 索引。

可能很多人又有疑问了，既然 Hash 索引的效率要比 B+Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B+Tree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。

- **Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询。**由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。

- **Hash 索引无法被用来避免数据的排序操作。**由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；

- **Hash 索引不能利用部分索引键查询。**对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

- **Hash 索引在任何时候都不能避免表扫描。**前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。

- **Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B+Tree索引高。**对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下

简单地说，哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

 

## B+树索引和哈希索引的区别

- 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据;
- 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
- 同理，哈希索引也没办法利用索引完成排序，以及`like 'xxx%'` 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
- 哈希索引也不支持多列联合索引的最左匹配规则；
- B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

### 存储引擎对比

**`InnoDB` 现在是 `MySQL` 默认的存储引擎，支持事务、行级锁定和外键**

1. `InnoDB`支持事务，而`MyIsam`不支持事务。这是 `MySQL` 将默认存储引擎从 `MyISAM` 变成 ~的重要原因之一；
2. `InnoDB`的最小的锁粒度是行锁；`MyISAM` 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 `MySQL` 将默认存储引擎从 `MyISAM` 变成 `InnoDB` 的重要原因之一；

